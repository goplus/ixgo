// export by github.com/goplus/ixgo/cmd/qexp

//go:build go1.21 && !go1.22
// +build go1.21,!go1.22

package slog

import (
	"github.com/goplus/ixgo"
)

func init() {
	ixgo.RegisterPackage(&ixgo.Package{
		Name: "slog",
		Path: "log/slog",
		Deps: map[string]string{
			"bytes":                    "bytes",
			"context":                  "context",
			"encoding":                 "encoding",
			"encoding/json":            "json",
			"errors":                   "errors",
			"fmt":                      "fmt",
			"io":                       "io",
			"log":                      "log",
			"log/internal":             "internal",
			"log/slog/internal":        "internal",
			"log/slog/internal/buffer": "buffer",
			"math":                     "math",
			"reflect":                  "reflect",
			"runtime":                  "runtime",
			"slices":                   "slices",
			"strconv":                  "strconv",
			"strings":                  "strings",
			"sync":                     "sync",
			"sync/atomic":              "atomic",
			"time":                     "time",
			"unicode":                  "unicode",
			"unicode/utf8":             "utf8",
			"unsafe":                   "unsafe",
		},
		Source: source,
	})
}

var source = "package slog\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"context\"\n\t\"io\"\n\t\"log/slog/internal/buffer\"\n\t\"slices\"\n\t\"strconv\"\n\t\"sync\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"unicode/utf8\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"log\"\n\n\tloginternal \"log/internal\"\n\t\"log/slog/internal\"\n\t\"runtime\"\n\t\"encoding\"\n\t\"reflect\"\n\t\"unicode\"\n\t\"math\"\n\t\"unsafe\"\n)\n\ntype Attr struct {\n\tKey\tstring\n\tValue\tValue\n}\n\nfunc String(key, value string) Attr {\n\treturn Attr{key, StringValue(value)}\n}\n\nfunc Int64(key string, value int64) Attr {\n\treturn Attr{key, Int64Value(value)}\n}\n\nfunc Int(key string, value int) Attr {\n\treturn Int64(key, int64(value))\n}\n\nfunc Uint64(key string, v uint64) Attr {\n\treturn Attr{key, Uint64Value(v)}\n}\n\nfunc Float64(key string, v float64) Attr {\n\treturn Attr{key, Float64Value(v)}\n}\n\nfunc Bool(key string, v bool) Attr {\n\treturn Attr{key, BoolValue(v)}\n}\n\nfunc Time(key string, v time.Time) Attr {\n\treturn Attr{key, TimeValue(v)}\n}\n\nfunc Duration(key string, v time.Duration) Attr {\n\treturn Attr{key, DurationValue(v)}\n}\n\nfunc Group(key string, args ...any) Attr {\n\treturn Attr{key, GroupValue(argsToAttrSlice(args)...)}\n}\n\nfunc argsToAttrSlice(args []any) []Attr {\n\tvar (\n\t\tattr\tAttr\n\t\tattrs\t[]Attr\n\t)\n\tfor len(args) > 0 {\n\t\tattr, args = argsToAttr(args)\n\t\tattrs = append(attrs, attr)\n\t}\n\treturn attrs\n}\n\nfunc Any(key string, value any) Attr {\n\treturn Attr{key, AnyValue(value)}\n}\n\nfunc (a Attr) Equal(b Attr) bool {\n\treturn a.Key == b.Key && a.Value.Equal(b.Value)\n}\n\nfunc (a Attr) String() string {\n\treturn fmt.Sprintf(\"%s=%s\", a.Key, a.Value)\n}\n\nfunc (a Attr) isEmpty() bool {\n\treturn a.Key == \"\" && a.Value.num == 0 && a.Value.any == nil\n}\n\ntype Handler interface {\n\tEnabled(context.Context, Level) bool\n\n\tHandle(context.Context, Record) error\n\n\tWithAttrs(attrs []Attr) Handler\n\n\tWithGroup(name string) Handler\n}\n\ntype defaultHandler struct {\n\tch\t*commonHandler\n\n\toutput\tfunc(pc uintptr, data []byte) error\n}\n\nfunc newDefaultHandler(output func(uintptr, []byte) error) *defaultHandler {\n\treturn &defaultHandler{\n\t\tch:\t&commonHandler{json: false},\n\t\toutput:\toutput,\n\t}\n}\n\nfunc (*defaultHandler) Enabled(_ context.Context, l Level) bool {\n\treturn l >= LevelInfo\n}\n\nfunc (h *defaultHandler) Handle(ctx context.Context, r Record) error {\n\tbuf := buffer.New()\n\tbuf.WriteString(r.Level.String())\n\tbuf.WriteByte(' ')\n\tbuf.WriteString(r.Message)\n\tstate := h.ch.newHandleState(buf, true, \" \")\n\tdefer state.free()\n\tstate.appendNonBuiltIns(r)\n\treturn h.output(r.PC, *buf)\n}\n\nfunc (h *defaultHandler) WithAttrs(as []Attr) Handler {\n\treturn &defaultHandler{h.ch.withAttrs(as), h.output}\n}\n\nfunc (h *defaultHandler) WithGroup(name string) Handler {\n\treturn &defaultHandler{h.ch.withGroup(name), h.output}\n}\n\ntype HandlerOptions struct {\n\tAddSource\tbool\n\n\tLevel\tLeveler\n\n\tReplaceAttr\tfunc(groups []string, a Attr) Attr\n}\n\nconst (\n\tTimeKey\t= \"time\"\n\n\tLevelKey\t= \"level\"\n\n\tMessageKey\t= \"msg\"\n\n\tSourceKey\t= \"source\"\n)\n\ntype commonHandler struct {\n\tjson\t\t\tbool\n\topts\t\t\tHandlerOptions\n\tpreformattedAttrs\t[]byte\n\n\tgroupPrefix\tstring\n\tgroups\t\t[]string\n\tnOpenGroups\tint\n\tmu\t\t*sync.Mutex\n\tw\t\tio.Writer\n}\n\nfunc (h *commonHandler) clone() *commonHandler {\n\n\treturn &commonHandler{\n\t\tjson:\t\t\th.json,\n\t\topts:\t\t\th.opts,\n\t\tpreformattedAttrs:\tslices.Clip(h.preformattedAttrs),\n\t\tgroupPrefix:\t\th.groupPrefix,\n\t\tgroups:\t\t\tslices.Clip(h.groups),\n\t\tnOpenGroups:\t\th.nOpenGroups,\n\t\tw:\t\t\th.w,\n\t\tmu:\t\t\th.mu,\n\t}\n}\n\nfunc (h *commonHandler) enabled(l Level) bool {\n\tminLevel := LevelInfo\n\tif h.opts.Level != nil {\n\t\tminLevel = h.opts.Level.Level()\n\t}\n\treturn l >= minLevel\n}\n\nfunc (h *commonHandler) withAttrs(as []Attr) *commonHandler {\n\n\tif countEmptyGroups(as) == len(as) {\n\t\treturn h\n\t}\n\th2 := h.clone()\n\n\tstate := h2.newHandleState((*buffer.Buffer)(&h2.preformattedAttrs), false, \"\")\n\tdefer state.free()\n\tstate.prefix.WriteString(h.groupPrefix)\n\tif len(h2.preformattedAttrs) > 0 {\n\t\tstate.sep = h.attrSep()\n\t}\n\tstate.openGroups()\n\tfor _, a := range as {\n\t\tstate.appendAttr(a)\n\t}\n\n\th2.groupPrefix = state.prefix.String()\n\n\th2.nOpenGroups = len(h2.groups)\n\treturn h2\n}\n\nfunc (h *commonHandler) withGroup(name string) *commonHandler {\n\th2 := h.clone()\n\th2.groups = append(h2.groups, name)\n\treturn h2\n}\n\nfunc (h *commonHandler) handle(r Record) error {\n\tstate := h.newHandleState(buffer.New(), true, \"\")\n\tdefer state.free()\n\tif h.json {\n\t\tstate.buf.WriteByte('{')\n\t}\n\n\tstateGroups := state.groups\n\tstate.groups = nil\n\trep := h.opts.ReplaceAttr\n\n\tif !r.Time.IsZero() {\n\t\tkey := TimeKey\n\t\tval := r.Time.Round(0)\n\t\tif rep == nil {\n\t\t\tstate.appendKey(key)\n\t\t\tstate.appendTime(val)\n\t\t} else {\n\t\t\tstate.appendAttr(Time(key, val))\n\t\t}\n\t}\n\n\tkey := LevelKey\n\tval := r.Level\n\tif rep == nil {\n\t\tstate.appendKey(key)\n\t\tstate.appendString(val.String())\n\t} else {\n\t\tstate.appendAttr(Any(key, val))\n\t}\n\n\tif h.opts.AddSource {\n\t\tstate.appendAttr(Any(SourceKey, r.source()))\n\t}\n\tkey = MessageKey\n\tmsg := r.Message\n\tif rep == nil {\n\t\tstate.appendKey(key)\n\t\tstate.appendString(msg)\n\t} else {\n\t\tstate.appendAttr(String(key, msg))\n\t}\n\tstate.groups = stateGroups\n\tstate.appendNonBuiltIns(r)\n\tstate.buf.WriteByte('\\n')\n\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\t_, err := h.w.Write(*state.buf)\n\treturn err\n}\n\nfunc (s *handleState) appendNonBuiltIns(r Record) {\n\n\tif len(s.h.preformattedAttrs) > 0 {\n\t\ts.buf.WriteString(s.sep)\n\t\ts.buf.Write(s.h.preformattedAttrs)\n\t\ts.sep = s.h.attrSep()\n\t}\n\n\tnOpenGroups := s.h.nOpenGroups\n\tif r.NumAttrs() > 0 {\n\t\ts.prefix.WriteString(s.h.groupPrefix)\n\t\ts.openGroups()\n\t\tnOpenGroups = len(s.h.groups)\n\t\tr.Attrs(func(a Attr) bool {\n\t\t\ts.appendAttr(a)\n\t\t\treturn true\n\t\t})\n\t}\n\tif s.h.json {\n\n\t\tfor range s.h.groups[:nOpenGroups] {\n\t\t\ts.buf.WriteByte('}')\n\t\t}\n\n\t\ts.buf.WriteByte('}')\n\t}\n}\n\nfunc (h *commonHandler) attrSep() string {\n\tif h.json {\n\t\treturn \",\"\n\t}\n\treturn \" \"\n}\n\ntype handleState struct {\n\th\t*commonHandler\n\tbuf\t*buffer.Buffer\n\tfreeBuf\tbool\n\tsep\tstring\n\tprefix\t*buffer.Buffer\n\tgroups\t*[]string\n}\n\nvar groupPool = sync.Pool{New: func() any {\n\ts := make([]string, 0, 10)\n\treturn &s\n}}\n\nfunc (h *commonHandler) newHandleState(buf *buffer.Buffer, freeBuf bool, sep string) handleState {\n\ts := handleState{\n\t\th:\t\th,\n\t\tbuf:\t\tbuf,\n\t\tfreeBuf:\tfreeBuf,\n\t\tsep:\t\tsep,\n\t\tprefix:\t\tbuffer.New(),\n\t}\n\tif h.opts.ReplaceAttr != nil {\n\t\ts.groups = groupPool.Get().(*[]string)\n\t\t*s.groups = append(*s.groups, h.groups[:h.nOpenGroups]...)\n\t}\n\treturn s\n}\n\nfunc (s *handleState) free() {\n\tif s.freeBuf {\n\t\ts.buf.Free()\n\t}\n\tif gs := s.groups; gs != nil {\n\t\t*gs = (*gs)[:0]\n\t\tgroupPool.Put(gs)\n\t}\n\ts.prefix.Free()\n}\n\nfunc (s *handleState) openGroups() {\n\tfor _, n := range s.h.groups[s.h.nOpenGroups:] {\n\t\ts.openGroup(n)\n\t}\n}\n\nconst keyComponentSep = '.'\n\nfunc (s *handleState) openGroup(name string) {\n\tif s.h.json {\n\t\ts.appendKey(name)\n\t\ts.buf.WriteByte('{')\n\t\ts.sep = \"\"\n\t} else {\n\t\ts.prefix.WriteString(name)\n\t\ts.prefix.WriteByte(keyComponentSep)\n\t}\n\n\tif s.groups != nil {\n\t\t*s.groups = append(*s.groups, name)\n\t}\n}\n\nfunc (s *handleState) closeGroup(name string) {\n\tif s.h.json {\n\t\ts.buf.WriteByte('}')\n\t} else {\n\t\t(*s.prefix) = (*s.prefix)[:len(*s.prefix)-len(name)-1]\n\t}\n\ts.sep = s.h.attrSep()\n\tif s.groups != nil {\n\t\t*s.groups = (*s.groups)[:len(*s.groups)-1]\n\t}\n}\n\nfunc (s *handleState) appendAttr(a Attr) {\n\tif rep := s.h.opts.ReplaceAttr; rep != nil && a.Value.Kind() != KindGroup {\n\t\tvar gs []string\n\t\tif s.groups != nil {\n\t\t\tgs = *s.groups\n\t\t}\n\n\t\ta.Value = a.Value.Resolve()\n\t\ta = rep(gs, a)\n\t}\n\ta.Value = a.Value.Resolve()\n\n\tif a.isEmpty() {\n\t\treturn\n\t}\n\n\tif v := a.Value; v.Kind() == KindAny {\n\t\tif src, ok := v.Any().(*Source); ok {\n\t\t\tif s.h.json {\n\t\t\t\ta.Value = src.group()\n\t\t\t} else {\n\t\t\t\ta.Value = StringValue(fmt.Sprintf(\"%s:%d\", src.File, src.Line))\n\t\t\t}\n\t\t}\n\t}\n\tif a.Value.Kind() == KindGroup {\n\t\tattrs := a.Value.Group()\n\n\t\tif len(attrs) > 0 {\n\n\t\t\tif a.Key != \"\" {\n\t\t\t\ts.openGroup(a.Key)\n\t\t\t}\n\t\t\tfor _, aa := range attrs {\n\t\t\t\ts.appendAttr(aa)\n\t\t\t}\n\t\t\tif a.Key != \"\" {\n\t\t\t\ts.closeGroup(a.Key)\n\t\t\t}\n\t\t}\n\t} else {\n\t\ts.appendKey(a.Key)\n\t\ts.appendValue(a.Value)\n\t}\n}\n\nfunc (s *handleState) appendError(err error) {\n\ts.appendString(fmt.Sprintf(\"!ERROR:%v\", err))\n}\n\nfunc (s *handleState) appendKey(key string) {\n\ts.buf.WriteString(s.sep)\n\tif s.prefix != nil && len(*s.prefix) > 0 {\n\n\t\ts.appendString(string(*s.prefix) + key)\n\t} else {\n\t\ts.appendString(key)\n\t}\n\tif s.h.json {\n\t\ts.buf.WriteByte(':')\n\t} else {\n\t\ts.buf.WriteByte('=')\n\t}\n\ts.sep = s.h.attrSep()\n}\n\nfunc (s *handleState) appendString(str string) {\n\tif s.h.json {\n\t\ts.buf.WriteByte('\"')\n\t\t*s.buf = appendEscapedJSONString(*s.buf, str)\n\t\ts.buf.WriteByte('\"')\n\t} else {\n\n\t\tif needsQuoting(str) {\n\t\t\t*s.buf = strconv.AppendQuote(*s.buf, str)\n\t\t} else {\n\t\t\ts.buf.WriteString(str)\n\t\t}\n\t}\n}\n\nfunc (s *handleState) appendValue(v Value) {\n\tvar err error\n\tif s.h.json {\n\t\terr = appendJSONValue(s, v)\n\t} else {\n\t\terr = appendTextValue(s, v)\n\t}\n\tif err != nil {\n\t\ts.appendError(err)\n\t}\n}\n\nfunc (s *handleState) appendTime(t time.Time) {\n\tif s.h.json {\n\t\tappendJSONTime(s, t)\n\t} else {\n\t\twriteTimeRFC3339Millis(s.buf, t)\n\t}\n}\n\nfunc writeTimeRFC3339Millis(buf *buffer.Buffer, t time.Time) {\n\tyear, month, day := t.Date()\n\tbuf.WritePosIntWidth(year, 4)\n\tbuf.WriteByte('-')\n\tbuf.WritePosIntWidth(int(month), 2)\n\tbuf.WriteByte('-')\n\tbuf.WritePosIntWidth(day, 2)\n\tbuf.WriteByte('T')\n\thour, min, sec := t.Clock()\n\tbuf.WritePosIntWidth(hour, 2)\n\tbuf.WriteByte(':')\n\tbuf.WritePosIntWidth(min, 2)\n\tbuf.WriteByte(':')\n\tbuf.WritePosIntWidth(sec, 2)\n\tns := t.Nanosecond()\n\tbuf.WriteByte('.')\n\tbuf.WritePosIntWidth(ns/1e6, 3)\n\t_, offsetSeconds := t.Zone()\n\tif offsetSeconds == 0 {\n\t\tbuf.WriteByte('Z')\n\t} else {\n\t\toffsetMinutes := offsetSeconds / 60\n\t\tif offsetMinutes < 0 {\n\t\t\tbuf.WriteByte('-')\n\t\t\toffsetMinutes = -offsetMinutes\n\t\t} else {\n\t\t\tbuf.WriteByte('+')\n\t\t}\n\t\tbuf.WritePosIntWidth(offsetMinutes/60, 2)\n\t\tbuf.WriteByte(':')\n\t\tbuf.WritePosIntWidth(offsetMinutes%60, 2)\n\t}\n}\n\ntype JSONHandler struct {\n\t*commonHandler\n}\n\nfunc NewJSONHandler(w io.Writer, opts *HandlerOptions) *JSONHandler {\n\tif opts == nil {\n\t\topts = &HandlerOptions{}\n\t}\n\treturn &JSONHandler{\n\t\t&commonHandler{\n\t\t\tjson:\ttrue,\n\t\t\tw:\tw,\n\t\t\topts:\t*opts,\n\t\t\tmu:\t&sync.Mutex{},\n\t\t},\n\t}\n}\n\nfunc (h *JSONHandler) Enabled(_ context.Context, level Level) bool {\n\treturn h.commonHandler.enabled(level)\n}\n\nfunc (h *JSONHandler) WithAttrs(attrs []Attr) Handler {\n\treturn &JSONHandler{commonHandler: h.commonHandler.withAttrs(attrs)}\n}\n\nfunc (h *JSONHandler) WithGroup(name string) Handler {\n\treturn &JSONHandler{commonHandler: h.commonHandler.withGroup(name)}\n}\n\nfunc (h *JSONHandler) Handle(_ context.Context, r Record) error {\n\treturn h.commonHandler.handle(r)\n}\n\nfunc appendJSONTime(s *handleState, t time.Time) {\n\tif y := t.Year(); y < 0 || y >= 10000 {\n\n\t\ts.appendError(errors.New(\"time.Time year outside of range [0,9999]\"))\n\t}\n\ts.buf.WriteByte('\"')\n\t*s.buf = t.AppendFormat(*s.buf, time.RFC3339Nano)\n\ts.buf.WriteByte('\"')\n}\n\nfunc appendJSONValue(s *handleState, v Value) error {\n\tswitch v.Kind() {\n\tcase KindString:\n\t\ts.appendString(v.str())\n\tcase KindInt64:\n\t\t*s.buf = strconv.AppendInt(*s.buf, v.Int64(), 10)\n\tcase KindUint64:\n\t\t*s.buf = strconv.AppendUint(*s.buf, v.Uint64(), 10)\n\tcase KindFloat64:\n\n\t\tif err := appendJSONMarshal(s.buf, v.Float64()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase KindBool:\n\t\t*s.buf = strconv.AppendBool(*s.buf, v.Bool())\n\tcase KindDuration:\n\n\t\t*s.buf = strconv.AppendInt(*s.buf, int64(v.Duration()), 10)\n\tcase KindTime:\n\t\ts.appendTime(v.Time())\n\tcase KindAny:\n\t\ta := v.Any()\n\t\t_, jm := a.(json.Marshaler)\n\t\tif err, ok := a.(error); ok && !jm {\n\t\t\ts.appendString(err.Error())\n\t\t} else {\n\t\t\treturn appendJSONMarshal(s.buf, a)\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"bad kind: %s\", v.Kind()))\n\t}\n\treturn nil\n}\n\nfunc appendJSONMarshal(buf *buffer.Buffer, v any) error {\n\n\tvar bb bytes.Buffer\n\tenc := json.NewEncoder(&bb)\n\tenc.SetEscapeHTML(false)\n\tif err := enc.Encode(v); err != nil {\n\t\treturn err\n\t}\n\tbs := bb.Bytes()\n\tbuf.Write(bs[:len(bs)-1])\n\treturn nil\n}\n\nfunc appendEscapedJSONString(buf []byte, s string) []byte {\n\tchar := func(b byte) { buf = append(buf, b) }\n\tstr := func(s string) { buf = append(buf, s...) }\n\n\tstart := 0\n\tfor i := 0; i < len(s); {\n\t\tif b := s[i]; b < utf8.RuneSelf {\n\t\t\tif safeSet[b] {\n\t\t\t\ti++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif start < i {\n\t\t\t\tstr(s[start:i])\n\t\t\t}\n\t\t\tchar('\\\\')\n\t\t\tswitch b {\n\t\t\tcase '\\\\', '\"':\n\t\t\t\tchar(b)\n\t\t\tcase '\\n':\n\t\t\t\tchar('n')\n\t\t\tcase '\\r':\n\t\t\t\tchar('r')\n\t\t\tcase '\\t':\n\t\t\t\tchar('t')\n\t\t\tdefault:\n\n\t\t\t\tstr(`u00`)\n\t\t\t\tchar(hex[b>>4])\n\t\t\t\tchar(hex[b&0xF])\n\t\t\t}\n\t\t\ti++\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\tc, size := utf8.DecodeRuneInString(s[i:])\n\t\tif c == utf8.RuneError && size == 1 {\n\t\t\tif start < i {\n\t\t\t\tstr(s[start:i])\n\t\t\t}\n\t\t\tstr(`\\ufffd`)\n\t\t\ti += size\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\n\t\tif c == '\\u2028' || c == '\\u2029' {\n\t\t\tif start < i {\n\t\t\t\tstr(s[start:i])\n\t\t\t}\n\t\t\tstr(`\\u202`)\n\t\t\tchar(hex[c&0xF])\n\t\t\ti += size\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\ti += size\n\t}\n\tif start < len(s) {\n\t\tstr(s[start:])\n\t}\n\treturn buf\n}\n\nvar hex = \"0123456789abcdef\"\n\nvar safeSet = [utf8.RuneSelf]bool{\n\t' ':\t\ttrue,\n\t'!':\t\ttrue,\n\t'\"':\t\tfalse,\n\t'#':\t\ttrue,\n\t'$':\t\ttrue,\n\t'%':\t\ttrue,\n\t'&':\t\ttrue,\n\t'\\'':\t\ttrue,\n\t'(':\t\ttrue,\n\t')':\t\ttrue,\n\t'*':\t\ttrue,\n\t'+':\t\ttrue,\n\t',':\t\ttrue,\n\t'-':\t\ttrue,\n\t'.':\t\ttrue,\n\t'/':\t\ttrue,\n\t'0':\t\ttrue,\n\t'1':\t\ttrue,\n\t'2':\t\ttrue,\n\t'3':\t\ttrue,\n\t'4':\t\ttrue,\n\t'5':\t\ttrue,\n\t'6':\t\ttrue,\n\t'7':\t\ttrue,\n\t'8':\t\ttrue,\n\t'9':\t\ttrue,\n\t':':\t\ttrue,\n\t';':\t\ttrue,\n\t'<':\t\ttrue,\n\t'=':\t\ttrue,\n\t'>':\t\ttrue,\n\t'?':\t\ttrue,\n\t'@':\t\ttrue,\n\t'A':\t\ttrue,\n\t'B':\t\ttrue,\n\t'C':\t\ttrue,\n\t'D':\t\ttrue,\n\t'E':\t\ttrue,\n\t'F':\t\ttrue,\n\t'G':\t\ttrue,\n\t'H':\t\ttrue,\n\t'I':\t\ttrue,\n\t'J':\t\ttrue,\n\t'K':\t\ttrue,\n\t'L':\t\ttrue,\n\t'M':\t\ttrue,\n\t'N':\t\ttrue,\n\t'O':\t\ttrue,\n\t'P':\t\ttrue,\n\t'Q':\t\ttrue,\n\t'R':\t\ttrue,\n\t'S':\t\ttrue,\n\t'T':\t\ttrue,\n\t'U':\t\ttrue,\n\t'V':\t\ttrue,\n\t'W':\t\ttrue,\n\t'X':\t\ttrue,\n\t'Y':\t\ttrue,\n\t'Z':\t\ttrue,\n\t'[':\t\ttrue,\n\t'\\\\':\t\tfalse,\n\t']':\t\ttrue,\n\t'^':\t\ttrue,\n\t'_':\t\ttrue,\n\t'`':\t\ttrue,\n\t'a':\t\ttrue,\n\t'b':\t\ttrue,\n\t'c':\t\ttrue,\n\t'd':\t\ttrue,\n\t'e':\t\ttrue,\n\t'f':\t\ttrue,\n\t'g':\t\ttrue,\n\t'h':\t\ttrue,\n\t'i':\t\ttrue,\n\t'j':\t\ttrue,\n\t'k':\t\ttrue,\n\t'l':\t\ttrue,\n\t'm':\t\ttrue,\n\t'n':\t\ttrue,\n\t'o':\t\ttrue,\n\t'p':\t\ttrue,\n\t'q':\t\ttrue,\n\t'r':\t\ttrue,\n\t's':\t\ttrue,\n\t't':\t\ttrue,\n\t'u':\t\ttrue,\n\t'v':\t\ttrue,\n\t'w':\t\ttrue,\n\t'x':\t\ttrue,\n\t'y':\t\ttrue,\n\t'z':\t\ttrue,\n\t'{':\t\ttrue,\n\t'|':\t\ttrue,\n\t'}':\t\ttrue,\n\t'~':\t\ttrue,\n\t'\\u007f':\ttrue,\n}\n\ntype Level int\n\nconst (\n\tLevelDebug\tLevel\t= -4\n\tLevelInfo\tLevel\t= 0\n\tLevelWarn\tLevel\t= 4\n\tLevelError\tLevel\t= 8\n)\n\nfunc (l Level) String() string {\n\tstr := func(base string, val Level) string {\n\t\tif val == 0 {\n\t\t\treturn base\n\t\t}\n\t\treturn fmt.Sprintf(\"%s%+d\", base, val)\n\t}\n\n\tswitch {\n\tcase l < LevelInfo:\n\t\treturn str(\"DEBUG\", l-LevelDebug)\n\tcase l < LevelWarn:\n\t\treturn str(\"INFO\", l-LevelInfo)\n\tcase l < LevelError:\n\t\treturn str(\"WARN\", l-LevelWarn)\n\tdefault:\n\t\treturn str(\"ERROR\", l-LevelError)\n\t}\n}\n\nfunc (l Level) MarshalJSON() ([]byte, error) {\n\n\treturn strconv.AppendQuote(nil, l.String()), nil\n}\n\nfunc (l *Level) UnmarshalJSON(data []byte) error {\n\ts, err := strconv.Unquote(string(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn l.parse(s)\n}\n\nfunc (l Level) MarshalText() ([]byte, error) {\n\treturn []byte(l.String()), nil\n}\n\nfunc (l *Level) UnmarshalText(data []byte) error {\n\treturn l.parse(string(data))\n}\n\nfunc (l *Level) parse(s string) (err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"slog: level string %q: %w\", s, err)\n\t\t}\n\t}()\n\n\tname := s\n\toffset := 0\n\tif i := strings.IndexAny(s, \"+-\"); i >= 0 {\n\t\tname = s[:i]\n\t\toffset, err = strconv.Atoi(s[i:])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tswitch strings.ToUpper(name) {\n\tcase \"DEBUG\":\n\t\t*l = LevelDebug\n\tcase \"INFO\":\n\t\t*l = LevelInfo\n\tcase \"WARN\":\n\t\t*l = LevelWarn\n\tcase \"ERROR\":\n\t\t*l = LevelError\n\tdefault:\n\t\treturn errors.New(\"unknown name\")\n\t}\n\t*l += Level(offset)\n\treturn nil\n}\n\nfunc (l Level) Level() Level\t{ return l }\n\ntype LevelVar struct {\n\tval atomic.Int64\n}\n\nfunc (v *LevelVar) Level() Level {\n\treturn Level(int(v.val.Load()))\n}\n\nfunc (v *LevelVar) Set(l Level) {\n\tv.val.Store(int64(l))\n}\n\nfunc (v *LevelVar) String() string {\n\treturn fmt.Sprintf(\"LevelVar(%s)\", v.Level())\n}\n\nfunc (v *LevelVar) MarshalText() ([]byte, error) {\n\treturn v.Level().MarshalText()\n}\n\nfunc (v *LevelVar) UnmarshalText(data []byte) error {\n\tvar l Level\n\tif err := l.UnmarshalText(data); err != nil {\n\t\treturn err\n\t}\n\tv.Set(l)\n\treturn nil\n}\n\ntype Leveler interface {\n\tLevel() Level\n}\n\nvar defaultLogger atomic.Value\n\nfunc init() {\n\tdefaultLogger.Store(New(newDefaultHandler(loginternal.DefaultOutput)))\n}\n\nfunc Default() *Logger\t{ return defaultLogger.Load().(*Logger) }\n\nfunc SetDefault(l *Logger) {\n\tdefaultLogger.Store(l)\n\n\tif _, ok := l.Handler().(*defaultHandler); !ok {\n\t\tcapturePC := log.Flags()&(log.Lshortfile|log.Llongfile) != 0\n\t\tlog.SetOutput(&handlerWriter{l.Handler(), LevelInfo, capturePC})\n\t\tlog.SetFlags(0)\n\t}\n}\n\ntype handlerWriter struct {\n\th\t\tHandler\n\tlevel\t\tLevel\n\tcapturePC\tbool\n}\n\nfunc (w *handlerWriter) Write(buf []byte) (int, error) {\n\tif !w.h.Enabled(context.Background(), w.level) {\n\t\treturn 0, nil\n\t}\n\tvar pc uintptr\n\tif !internal.IgnorePC && w.capturePC {\n\n\t\tvar pcs [1]uintptr\n\t\truntime.Callers(4, pcs[:])\n\t\tpc = pcs[0]\n\t}\n\n\torigLen := len(buf)\n\tif len(buf) > 0 && buf[len(buf)-1] == '\\n' {\n\t\tbuf = buf[:len(buf)-1]\n\t}\n\tr := NewRecord(time.Now(), w.level, string(buf), pc)\n\treturn origLen, w.h.Handle(context.Background(), r)\n}\n\ntype Logger struct {\n\thandler Handler\n}\n\nfunc (l *Logger) clone() *Logger {\n\tc := *l\n\treturn &c\n}\n\nfunc (l *Logger) Handler() Handler\t{ return l.handler }\n\nfunc (l *Logger) With(args ...any) *Logger {\n\tif len(args) == 0 {\n\t\treturn l\n\t}\n\tc := l.clone()\n\tc.handler = l.handler.WithAttrs(argsToAttrSlice(args))\n\treturn c\n}\n\nfunc (l *Logger) WithGroup(name string) *Logger {\n\tif name == \"\" {\n\t\treturn l\n\t}\n\tc := l.clone()\n\tc.handler = l.handler.WithGroup(name)\n\treturn c\n\n}\n\nfunc New(h Handler) *Logger {\n\tif h == nil {\n\t\tpanic(\"nil Handler\")\n\t}\n\treturn &Logger{handler: h}\n}\n\nfunc With(args ...any) *Logger {\n\treturn Default().With(args...)\n}\n\nfunc (l *Logger) Enabled(ctx context.Context, level Level) bool {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\treturn l.Handler().Enabled(ctx, level)\n}\n\nfunc NewLogLogger(h Handler, level Level) *log.Logger {\n\treturn log.New(&handlerWriter{h, level, true}, \"\", 0)\n}\n\nfunc (l *Logger) Log(ctx context.Context, level Level, msg string, args ...any) {\n\tl.log(ctx, level, msg, args...)\n}\n\nfunc (l *Logger) LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr) {\n\tl.logAttrs(ctx, level, msg, attrs...)\n}\n\nfunc (l *Logger) Debug(msg string, args ...any) {\n\tl.log(context.Background(), LevelDebug, msg, args...)\n}\n\nfunc (l *Logger) DebugContext(ctx context.Context, msg string, args ...any) {\n\tl.log(ctx, LevelDebug, msg, args...)\n}\n\nfunc (l *Logger) Info(msg string, args ...any) {\n\tl.log(context.Background(), LevelInfo, msg, args...)\n}\n\nfunc (l *Logger) InfoContext(ctx context.Context, msg string, args ...any) {\n\tl.log(ctx, LevelInfo, msg, args...)\n}\n\nfunc (l *Logger) Warn(msg string, args ...any) {\n\tl.log(context.Background(), LevelWarn, msg, args...)\n}\n\nfunc (l *Logger) WarnContext(ctx context.Context, msg string, args ...any) {\n\tl.log(ctx, LevelWarn, msg, args...)\n}\n\nfunc (l *Logger) Error(msg string, args ...any) {\n\tl.log(context.Background(), LevelError, msg, args...)\n}\n\nfunc (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any) {\n\tl.log(ctx, LevelError, msg, args...)\n}\n\nfunc (l *Logger) log(ctx context.Context, level Level, msg string, args ...any) {\n\tif !l.Enabled(ctx, level) {\n\t\treturn\n\t}\n\tvar pc uintptr\n\tif !internal.IgnorePC {\n\t\tvar pcs [1]uintptr\n\n\t\truntime.Callers(3, pcs[:])\n\t\tpc = pcs[0]\n\t}\n\tr := NewRecord(time.Now(), level, msg, pc)\n\tr.Add(args...)\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\t_ = l.Handler().Handle(ctx, r)\n}\n\nfunc (l *Logger) logAttrs(ctx context.Context, level Level, msg string, attrs ...Attr) {\n\tif !l.Enabled(ctx, level) {\n\t\treturn\n\t}\n\tvar pc uintptr\n\tif !internal.IgnorePC {\n\t\tvar pcs [1]uintptr\n\n\t\truntime.Callers(3, pcs[:])\n\t\tpc = pcs[0]\n\t}\n\tr := NewRecord(time.Now(), level, msg, pc)\n\tr.AddAttrs(attrs...)\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\t_ = l.Handler().Handle(ctx, r)\n}\n\nfunc Debug(msg string, args ...any) {\n\tDefault().log(context.Background(), LevelDebug, msg, args...)\n}\n\nfunc DebugContext(ctx context.Context, msg string, args ...any) {\n\tDefault().log(ctx, LevelDebug, msg, args...)\n}\n\nfunc Info(msg string, args ...any) {\n\tDefault().log(context.Background(), LevelInfo, msg, args...)\n}\n\nfunc InfoContext(ctx context.Context, msg string, args ...any) {\n\tDefault().log(ctx, LevelInfo, msg, args...)\n}\n\nfunc Warn(msg string, args ...any) {\n\tDefault().log(context.Background(), LevelWarn, msg, args...)\n}\n\nfunc WarnContext(ctx context.Context, msg string, args ...any) {\n\tDefault().log(ctx, LevelWarn, msg, args...)\n}\n\nfunc Error(msg string, args ...any) {\n\tDefault().log(context.Background(), LevelError, msg, args...)\n}\n\nfunc ErrorContext(ctx context.Context, msg string, args ...any) {\n\tDefault().log(ctx, LevelError, msg, args...)\n}\n\nfunc Log(ctx context.Context, level Level, msg string, args ...any) {\n\tDefault().log(ctx, level, msg, args...)\n}\n\nfunc LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr) {\n\tDefault().logAttrs(ctx, level, msg, attrs...)\n}\n\nconst nAttrsInline = 5\n\ntype Record struct {\n\tTime\ttime.Time\n\n\tMessage\tstring\n\n\tLevel\tLevel\n\n\tPC\tuintptr\n\n\tfront\t[nAttrsInline]Attr\n\n\tnFront\tint\n\n\tback\t[]Attr\n}\n\nfunc NewRecord(t time.Time, level Level, msg string, pc uintptr) Record {\n\treturn Record{\n\t\tTime:\t\tt,\n\t\tMessage:\tmsg,\n\t\tLevel:\t\tlevel,\n\t\tPC:\t\tpc,\n\t}\n}\n\nfunc (r Record) Clone() Record {\n\tr.back = slices.Clip(r.back)\n\treturn r\n}\n\nfunc (r Record) NumAttrs() int {\n\treturn r.nFront + len(r.back)\n}\n\nfunc (r Record) Attrs(f func(Attr) bool) {\n\tfor i := 0; i < r.nFront; i++ {\n\t\tif !f(r.front[i]) {\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, a := range r.back {\n\t\tif !f(a) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (r *Record) AddAttrs(attrs ...Attr) {\n\tvar i int\n\tfor i = 0; i < len(attrs) && r.nFront < len(r.front); i++ {\n\t\ta := attrs[i]\n\t\tif a.Value.isEmptyGroup() {\n\t\t\tcontinue\n\t\t}\n\t\tr.front[r.nFront] = a\n\t\tr.nFront++\n\t}\n\n\tif cap(r.back) > len(r.back) {\n\t\tend := r.back[:len(r.back)+1][len(r.back)]\n\t\tif !end.isEmpty() {\n\t\t\tpanic(\"copies of a slog.Record were both modified\")\n\t\t}\n\t}\n\tne := countEmptyGroups(attrs[i:])\n\tr.back = slices.Grow(r.back, len(attrs[i:])-ne)\n\tfor _, a := range attrs[i:] {\n\t\tif !a.Value.isEmptyGroup() {\n\t\t\tr.back = append(r.back, a)\n\t\t}\n\t}\n}\n\nfunc (r *Record) Add(args ...any) {\n\tvar a Attr\n\tfor len(args) > 0 {\n\t\ta, args = argsToAttr(args)\n\t\tif a.Value.isEmptyGroup() {\n\t\t\tcontinue\n\t\t}\n\t\tif r.nFront < len(r.front) {\n\t\t\tr.front[r.nFront] = a\n\t\t\tr.nFront++\n\t\t} else {\n\t\t\tif r.back == nil {\n\t\t\t\tr.back = make([]Attr, 0, countAttrs(args))\n\t\t\t}\n\t\t\tr.back = append(r.back, a)\n\t\t}\n\t}\n\n}\n\nfunc countAttrs(args []any) int {\n\tn := 0\n\tfor i := 0; i < len(args); i++ {\n\t\tn++\n\t\tif _, ok := args[i].(string); ok {\n\t\t\ti++\n\t\t}\n\t}\n\treturn n\n}\n\nconst badKey = \"!BADKEY\"\n\nfunc argsToAttr(args []any) (Attr, []any) {\n\tswitch x := args[0].(type) {\n\tcase string:\n\t\tif len(args) == 1 {\n\t\t\treturn String(badKey, x), nil\n\t\t}\n\t\treturn Any(x, args[1]), args[2:]\n\n\tcase Attr:\n\t\treturn x, args[1:]\n\n\tdefault:\n\t\treturn Any(badKey, x), args[1:]\n\t}\n}\n\ntype Source struct {\n\tFunction\tstring\t`json:\"function\"`\n\n\tFile\tstring\t`json:\"file\"`\n\tLine\tint\t`json:\"line\"`\n}\n\nfunc (s *Source) group() Value {\n\tvar as []Attr\n\tif s.Function != \"\" {\n\t\tas = append(as, String(\"function\", s.Function))\n\t}\n\tif s.File != \"\" {\n\t\tas = append(as, String(\"file\", s.File))\n\t}\n\tif s.Line != 0 {\n\t\tas = append(as, Int(\"line\", s.Line))\n\t}\n\treturn GroupValue(as...)\n}\n\nfunc (r Record) source() *Source {\n\tfs := runtime.CallersFrames([]uintptr{r.PC})\n\tf, _ := fs.Next()\n\treturn &Source{\n\t\tFunction:\tf.Function,\n\t\tFile:\t\tf.File,\n\t\tLine:\t\tf.Line,\n\t}\n}\n\ntype TextHandler struct {\n\t*commonHandler\n}\n\nfunc NewTextHandler(w io.Writer, opts *HandlerOptions) *TextHandler {\n\tif opts == nil {\n\t\topts = &HandlerOptions{}\n\t}\n\treturn &TextHandler{\n\t\t&commonHandler{\n\t\t\tjson:\tfalse,\n\t\t\tw:\tw,\n\t\t\topts:\t*opts,\n\t\t\tmu:\t&sync.Mutex{},\n\t\t},\n\t}\n}\n\nfunc (h *TextHandler) Enabled(_ context.Context, level Level) bool {\n\treturn h.commonHandler.enabled(level)\n}\n\nfunc (h *TextHandler) WithAttrs(attrs []Attr) Handler {\n\treturn &TextHandler{commonHandler: h.commonHandler.withAttrs(attrs)}\n}\n\nfunc (h *TextHandler) WithGroup(name string) Handler {\n\treturn &TextHandler{commonHandler: h.commonHandler.withGroup(name)}\n}\n\nfunc (h *TextHandler) Handle(_ context.Context, r Record) error {\n\treturn h.commonHandler.handle(r)\n}\n\nfunc appendTextValue(s *handleState, v Value) error {\n\tswitch v.Kind() {\n\tcase KindString:\n\t\ts.appendString(v.str())\n\tcase KindTime:\n\t\ts.appendTime(v.time())\n\tcase KindAny:\n\t\tif tm, ok := v.any.(encoding.TextMarshaler); ok {\n\t\t\tdata, err := tm.MarshalText()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ts.appendString(string(data))\n\t\t\treturn nil\n\t\t}\n\t\tif bs, ok := byteSlice(v.any); ok {\n\n\t\t\ts.buf.WriteString(strconv.Quote(string(bs)))\n\t\t\treturn nil\n\t\t}\n\t\ts.appendString(fmt.Sprintf(\"%+v\", v.Any()))\n\tdefault:\n\t\t*s.buf = v.append(*s.buf)\n\t}\n\treturn nil\n}\n\nfunc byteSlice(a any) ([]byte, bool) {\n\tif bs, ok := a.([]byte); ok {\n\t\treturn bs, true\n\t}\n\n\tt := reflect.TypeOf(a)\n\tif t != nil && t.Kind() == reflect.Slice && t.Elem().Kind() == reflect.Uint8 {\n\t\treturn reflect.ValueOf(a).Bytes(), true\n\t}\n\treturn nil, false\n}\n\nfunc needsQuoting(s string) bool {\n\tif len(s) == 0 {\n\t\treturn true\n\t}\n\tfor i := 0; i < len(s); {\n\t\tb := s[i]\n\t\tif b < utf8.RuneSelf {\n\n\t\t\tif b != '\\\\' && (b == ' ' || b == '=' || !safeSet[b]) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tr, size := utf8.DecodeRuneInString(s[i:])\n\t\tif r == utf8.RuneError || unicode.IsSpace(r) || !unicode.IsPrint(r) {\n\t\t\treturn true\n\t\t}\n\t\ti += size\n\t}\n\treturn false\n}\n\ntype Value struct {\n\t_\t[0]func()\n\n\tnum\tuint64\n\n\tany\tany\n}\n\ntype (\n\tstringptr\t*byte\n\tgroupptr\t*Attr\n)\n\ntype Kind int\n\nconst (\n\tKindAny\tKind\t= iota\n\tKindBool\n\tKindDuration\n\tKindFloat64\n\tKindInt64\n\tKindString\n\tKindTime\n\tKindUint64\n\tKindGroup\n\tKindLogValuer\n)\n\nvar kindStrings = []string{\n\t\"Any\",\n\t\"Bool\",\n\t\"Duration\",\n\t\"Float64\",\n\t\"Int64\",\n\t\"String\",\n\t\"Time\",\n\t\"Uint64\",\n\t\"Group\",\n\t\"LogValuer\",\n}\n\nfunc (k Kind) String() string {\n\tif k >= 0 && int(k) < len(kindStrings) {\n\t\treturn kindStrings[k]\n\t}\n\treturn \"<unknown slog.Kind>\"\n}\n\ntype kind Kind\n\nfunc (v Value) Kind() Kind {\n\tswitch x := v.any.(type) {\n\tcase Kind:\n\t\treturn x\n\tcase stringptr:\n\t\treturn KindString\n\tcase timeLocation:\n\t\treturn KindTime\n\tcase groupptr:\n\t\treturn KindGroup\n\tcase LogValuer:\n\t\treturn KindLogValuer\n\tcase kind:\n\t\treturn KindAny\n\tdefault:\n\t\treturn KindAny\n\t}\n}\n\nfunc StringValue(value string) Value {\n\treturn Value{num: uint64(len(value)), any: stringptr(unsafe.StringData(value))}\n}\n\nfunc IntValue(v int) Value {\n\treturn Int64Value(int64(v))\n}\n\nfunc Int64Value(v int64) Value {\n\treturn Value{num: uint64(v), any: KindInt64}\n}\n\nfunc Uint64Value(v uint64) Value {\n\treturn Value{num: v, any: KindUint64}\n}\n\nfunc Float64Value(v float64) Value {\n\treturn Value{num: math.Float64bits(v), any: KindFloat64}\n}\n\nfunc BoolValue(v bool) Value {\n\tu := uint64(0)\n\tif v {\n\t\tu = 1\n\t}\n\treturn Value{num: u, any: KindBool}\n}\n\ntype timeLocation *time.Location\n\nfunc TimeValue(v time.Time) Value {\n\tif v.IsZero() {\n\n\t\treturn Value{any: timeLocation(nil)}\n\t}\n\treturn Value{num: uint64(v.UnixNano()), any: timeLocation(v.Location())}\n}\n\nfunc DurationValue(v time.Duration) Value {\n\treturn Value{num: uint64(v.Nanoseconds()), any: KindDuration}\n}\n\nfunc GroupValue(as ...Attr) Value {\n\n\tif n := countEmptyGroups(as); n > 0 {\n\t\tas2 := make([]Attr, 0, len(as)-n)\n\t\tfor _, a := range as {\n\t\t\tif !a.Value.isEmptyGroup() {\n\t\t\t\tas2 = append(as2, a)\n\t\t\t}\n\t\t}\n\t\tas = as2\n\t}\n\treturn Value{num: uint64(len(as)), any: groupptr(unsafe.SliceData(as))}\n}\n\nfunc countEmptyGroups(as []Attr) int {\n\tn := 0\n\tfor _, a := range as {\n\t\tif a.Value.isEmptyGroup() {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\nfunc AnyValue(v any) Value {\n\tswitch v := v.(type) {\n\tcase string:\n\t\treturn StringValue(v)\n\tcase int:\n\t\treturn Int64Value(int64(v))\n\tcase uint:\n\t\treturn Uint64Value(uint64(v))\n\tcase int64:\n\t\treturn Int64Value(v)\n\tcase uint64:\n\t\treturn Uint64Value(v)\n\tcase bool:\n\t\treturn BoolValue(v)\n\tcase time.Duration:\n\t\treturn DurationValue(v)\n\tcase time.Time:\n\t\treturn TimeValue(v)\n\tcase uint8:\n\t\treturn Uint64Value(uint64(v))\n\tcase uint16:\n\t\treturn Uint64Value(uint64(v))\n\tcase uint32:\n\t\treturn Uint64Value(uint64(v))\n\tcase uintptr:\n\t\treturn Uint64Value(uint64(v))\n\tcase int8:\n\t\treturn Int64Value(int64(v))\n\tcase int16:\n\t\treturn Int64Value(int64(v))\n\tcase int32:\n\t\treturn Int64Value(int64(v))\n\tcase float64:\n\t\treturn Float64Value(v)\n\tcase float32:\n\t\treturn Float64Value(float64(v))\n\tcase []Attr:\n\t\treturn GroupValue(v...)\n\tcase Kind:\n\t\treturn Value{any: kind(v)}\n\tcase Value:\n\t\treturn v\n\tdefault:\n\t\treturn Value{any: v}\n\t}\n}\n\nfunc (v Value) Any() any {\n\tswitch v.Kind() {\n\tcase KindAny:\n\t\tif k, ok := v.any.(kind); ok {\n\t\t\treturn Kind(k)\n\t\t}\n\t\treturn v.any\n\tcase KindLogValuer:\n\t\treturn v.any\n\tcase KindGroup:\n\t\treturn v.group()\n\tcase KindInt64:\n\t\treturn int64(v.num)\n\tcase KindUint64:\n\t\treturn v.num\n\tcase KindFloat64:\n\t\treturn v.float()\n\tcase KindString:\n\t\treturn v.str()\n\tcase KindBool:\n\t\treturn v.bool()\n\tcase KindDuration:\n\t\treturn v.duration()\n\tcase KindTime:\n\t\treturn v.time()\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"bad kind: %s\", v.Kind()))\n\t}\n}\n\nfunc (v Value) String() string {\n\tif sp, ok := v.any.(stringptr); ok {\n\t\treturn unsafe.String(sp, v.num)\n\t}\n\tvar buf []byte\n\treturn string(v.append(buf))\n}\n\nfunc (v Value) str() string {\n\treturn unsafe.String(v.any.(stringptr), v.num)\n}\n\nfunc (v Value) Int64() int64 {\n\tif g, w := v.Kind(), KindInt64; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\treturn int64(v.num)\n}\n\nfunc (v Value) Uint64() uint64 {\n\tif g, w := v.Kind(), KindUint64; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\treturn v.num\n}\n\nfunc (v Value) Bool() bool {\n\tif g, w := v.Kind(), KindBool; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\treturn v.bool()\n}\n\nfunc (a Value) bool() bool {\n\treturn a.num == 1\n}\n\nfunc (a Value) Duration() time.Duration {\n\tif g, w := a.Kind(), KindDuration; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\n\treturn a.duration()\n}\n\nfunc (a Value) duration() time.Duration {\n\treturn time.Duration(int64(a.num))\n}\n\nfunc (v Value) Float64() float64 {\n\tif g, w := v.Kind(), KindFloat64; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\n\treturn v.float()\n}\n\nfunc (a Value) float() float64 {\n\treturn math.Float64frombits(a.num)\n}\n\nfunc (v Value) Time() time.Time {\n\tif g, w := v.Kind(), KindTime; g != w {\n\t\tpanic(fmt.Sprintf(\"Value kind is %s, not %s\", g, w))\n\t}\n\treturn v.time()\n}\n\nfunc (v Value) time() time.Time {\n\tloc := v.any.(timeLocation)\n\tif loc == nil {\n\t\treturn time.Time{}\n\t}\n\treturn time.Unix(0, int64(v.num)).In(loc)\n}\n\nfunc (v Value) LogValuer() LogValuer {\n\treturn v.any.(LogValuer)\n}\n\nfunc (v Value) Group() []Attr {\n\tif sp, ok := v.any.(groupptr); ok {\n\t\treturn unsafe.Slice((*Attr)(sp), v.num)\n\t}\n\tpanic(\"Group: bad kind\")\n}\n\nfunc (v Value) group() []Attr {\n\treturn unsafe.Slice((*Attr)(v.any.(groupptr)), v.num)\n}\n\nfunc (v Value) Equal(w Value) bool {\n\tk1 := v.Kind()\n\tk2 := w.Kind()\n\tif k1 != k2 {\n\t\treturn false\n\t}\n\tswitch k1 {\n\tcase KindInt64, KindUint64, KindBool, KindDuration:\n\t\treturn v.num == w.num\n\tcase KindString:\n\t\treturn v.str() == w.str()\n\tcase KindFloat64:\n\t\treturn v.float() == w.float()\n\tcase KindTime:\n\t\treturn v.time().Equal(w.time())\n\tcase KindAny, KindLogValuer:\n\t\treturn v.any == w.any\n\tcase KindGroup:\n\t\treturn slices.EqualFunc(v.group(), w.group(), Attr.Equal)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"bad kind: %s\", k1))\n\t}\n}\n\nfunc (v Value) isEmptyGroup() bool {\n\tif v.Kind() != KindGroup {\n\t\treturn false\n\t}\n\n\treturn len(v.group()) == 0\n}\n\nfunc (v Value) append(dst []byte) []byte {\n\tswitch v.Kind() {\n\tcase KindString:\n\t\treturn append(dst, v.str()...)\n\tcase KindInt64:\n\t\treturn strconv.AppendInt(dst, int64(v.num), 10)\n\tcase KindUint64:\n\t\treturn strconv.AppendUint(dst, v.num, 10)\n\tcase KindFloat64:\n\t\treturn strconv.AppendFloat(dst, v.float(), 'g', -1, 64)\n\tcase KindBool:\n\t\treturn strconv.AppendBool(dst, v.bool())\n\tcase KindDuration:\n\t\treturn append(dst, v.duration().String()...)\n\tcase KindTime:\n\t\treturn append(dst, v.time().String()...)\n\tcase KindGroup:\n\t\treturn fmt.Append(dst, v.group())\n\tcase KindAny, KindLogValuer:\n\t\treturn fmt.Append(dst, v.any)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"bad kind: %s\", v.Kind()))\n\t}\n}\n\ntype LogValuer interface {\n\tLogValue() Value\n}\n\nconst maxLogValues = 100\n\nfunc (v Value) Resolve() (rv Value) {\n\torig := v\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\trv = AnyValue(fmt.Errorf(\"LogValue panicked\\n%s\", stack(3, 5)))\n\t\t}\n\t}()\n\n\tfor i := 0; i < maxLogValues; i++ {\n\t\tif v.Kind() != KindLogValuer {\n\t\t\treturn v\n\t\t}\n\t\tv = v.LogValuer().LogValue()\n\t}\n\terr := fmt.Errorf(\"LogValue called too many times on Value of type %T\", orig.Any())\n\treturn AnyValue(err)\n}\n\nfunc stack(skip, nFrames int) string {\n\tpcs := make([]uintptr, nFrames+1)\n\tn := runtime.Callers(skip+1, pcs)\n\tif n == 0 {\n\t\treturn \"(no stack)\"\n\t}\n\tframes := runtime.CallersFrames(pcs[:n])\n\tvar b strings.Builder\n\ti := 0\n\tfor {\n\t\tframe, more := frames.Next()\n\t\tfmt.Fprintf(&b, \"called from %s (%s:%d)\\n\", frame.Function, frame.File, frame.Line)\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t\ti++\n\t\tif i >= nFrames {\n\t\t\tfmt.Fprintf(&b, \"(rest of stack elided)\\n\")\n\t\t\tbreak\n\t\t}\n\t}\n\treturn b.String()\n}\n"
