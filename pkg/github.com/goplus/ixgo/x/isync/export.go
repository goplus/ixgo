// export by github.com/goplus/ixgo/cmd/qexp

package isync

import (
	q "github.com/goplus/ixgo/x/isync"

	"go/constant"
	"reflect"

	"github.com/goplus/ixgo"
)

func init() {
	ixgo.RegisterPackage(&ixgo.Package{
		Name: "isync",
		Path: "github.com/goplus/ixgo/x/isync",
		Deps: map[string]string{
			"github.com/goplus/ixgo/x/abi": "abi",
			"math/rand":                    "rand",
			"sync":                         "sync",
			"sync/atomic":                  "atomic",
			"unsafe":                       "unsafe",
		},
		Interfaces:  map[string]reflect.Type{},
		NamedTypes:  map[string]reflect.Type{},
		AliasTypes:  map[string]reflect.Type{},
		Vars:        map[string]reflect.Value{},
		Funcs:       map[string]reflect.Value{},
		TypedConsts: map[string]ixgo.TypedConst{},
		UntypedConsts: map[string]ixgo.UntypedConst{
			"PtrSize": {"untyped int", constant.MakeInt64(int64(q.PtrSize))},
		},
		Source: source,
	})
}

var source = "package isync\n\nimport (\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"unsafe\"\n\t\"github.com/goplus/ixgo/x/abi\"\n)\n\nconst PtrSize = 4 << (^uintptr(0) >> 63)\n\ntype HashTrieMap[K comparable, V any] struct {\n\tinited\t\tatomic.Uint32\n\tinitMu\t\tsync.Mutex\n\troot\t\tatomic.Pointer[indirect[K, V]]\n\tkeyHash\t\thashFunc\n\tvalEqual\tequalFunc\n\tseed\t\tuintptr\n}\n\nfunc (ht *HashTrieMap[K, V]) init() {\n\tif ht.inited.Load() == 0 {\n\t\tht.initSlow()\n\t}\n}\n\nfunc (ht *HashTrieMap[K, V]) initSlow() {\n\tht.initMu.Lock()\n\tdefer ht.initMu.Unlock()\n\n\tif ht.inited.Load() != 0 {\n\n\t\treturn\n\t}\n\n\tvar m map[K]V\n\tmapType := abi.TypeOf(m).MapType()\n\tht.root.Store(newIndirectNode[K, V](nil))\n\tht.keyHash = mapType.Hasher\n\tht.valEqual = mapType.Elem.Equal\n\tht.seed = uintptr(runtime_rand())\n\n\tht.inited.Store(1)\n}\n\ntype hashFunc func(unsafe.Pointer, uintptr) uintptr\ntype equalFunc func(unsafe.Pointer, unsafe.Pointer) bool\n\nfunc (ht *HashTrieMap[K, V]) Load(key K) (value V, ok bool) {\n\tht.init()\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\n\ti := ht.root.Load()\n\thashShift := 8 * PtrSize\n\tfor hashShift != 0 {\n\t\thashShift -= nChildrenLog2\n\n\t\tn := i.children[(hash>>hashShift)&nChildrenMask].Load()\n\t\tif n == nil {\n\t\t\treturn *new(V), false\n\t\t}\n\t\tif n.isEntry {\n\t\t\treturn n.entry().lookup(key)\n\t\t}\n\t\ti = n.indirect()\n\t}\n\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n}\n\nfunc (ht *HashTrieMap[K, V]) LoadOrStore(key K, value V) (result V, loaded bool) {\n\tht.init()\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\tvar i *indirect[K, V]\n\tvar hashShift uint\n\tvar slot *atomic.Pointer[node[K, V]]\n\tvar n *node[K, V]\n\tfor {\n\n\t\ti = ht.root.Load()\n\t\thashShift = 8 * PtrSize\n\t\thaveInsertPoint := false\n\t\tfor hashShift != 0 {\n\t\t\thashShift -= nChildrenLog2\n\n\t\t\tslot = &i.children[(hash>>hashShift)&nChildrenMask]\n\t\t\tn = slot.Load()\n\t\t\tif n == nil {\n\n\t\t\t\thaveInsertPoint = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif n.isEntry {\n\n\t\t\t\tif v, ok := n.entry().lookup(key); ok {\n\t\t\t\t\treturn v, true\n\t\t\t\t}\n\t\t\t\thaveInsertPoint = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti = n.indirect()\n\t\t}\n\t\tif !haveInsertPoint {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n\t\t}\n\n\t\ti.mu.Lock()\n\t\tn = slot.Load()\n\t\tif (n == nil || n.isEntry) && !i.dead.Load() {\n\n\t\t\tbreak\n\t\t}\n\n\t\ti.mu.Unlock()\n\t}\n\n\tdefer i.mu.Unlock()\n\n\tvar oldEntry *entry[K, V]\n\tif n != nil {\n\t\toldEntry = n.entry()\n\t\tif v, ok := oldEntry.lookup(key); ok {\n\n\t\t\treturn v, true\n\t\t}\n\t}\n\tnewEntry := newEntryNode(key, value)\n\tif oldEntry == nil {\n\n\t\tslot.Store(&newEntry.node)\n\t} else {\n\n\t\tslot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))\n\t}\n\treturn value, false\n}\n\nfunc (ht *HashTrieMap[K, V]) expand(oldEntry, newEntry *entry[K, V], newHash uintptr, hashShift uint, parent *indirect[K, V]) *node[K, V] {\n\n\toldHash := ht.keyHash(unsafe.Pointer(&oldEntry.key), ht.seed)\n\tif oldHash == newHash {\n\n\t\tnewEntry.overflow.Store(oldEntry)\n\t\treturn &newEntry.node\n\t}\n\n\tnewIndirect := newIndirectNode(parent)\n\ttop := newIndirect\n\tfor {\n\t\tif hashShift == 0 {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while inserting\")\n\t\t}\n\t\thashShift -= nChildrenLog2\n\t\toi := (oldHash >> hashShift) & nChildrenMask\n\t\tni := (newHash >> hashShift) & nChildrenMask\n\t\tif oi != ni {\n\t\t\tnewIndirect.children[oi].Store(&oldEntry.node)\n\t\t\tnewIndirect.children[ni].Store(&newEntry.node)\n\t\t\tbreak\n\t\t}\n\t\tnextIndirect := newIndirectNode(newIndirect)\n\t\tnewIndirect.children[oi].Store(&nextIndirect.node)\n\t\tnewIndirect = nextIndirect\n\t}\n\treturn &top.node\n}\n\nfunc (ht *HashTrieMap[K, V]) Store(key K, old V) {\n\t_, _ = ht.Swap(key, old)\n}\n\nfunc (ht *HashTrieMap[K, V]) Swap(key K, new V) (previous V, loaded bool) {\n\tht.init()\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\tvar i *indirect[K, V]\n\tvar hashShift uint\n\tvar slot *atomic.Pointer[node[K, V]]\n\tvar n *node[K, V]\n\tfor {\n\n\t\ti = ht.root.Load()\n\t\thashShift = 8 * PtrSize\n\t\thaveInsertPoint := false\n\t\tfor hashShift != 0 {\n\t\t\thashShift -= nChildrenLog2\n\n\t\t\tslot = &i.children[(hash>>hashShift)&nChildrenMask]\n\t\t\tn = slot.Load()\n\t\t\tif n == nil || n.isEntry {\n\n\t\t\t\thaveInsertPoint = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti = n.indirect()\n\t\t}\n\t\tif !haveInsertPoint {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n\t\t}\n\n\t\ti.mu.Lock()\n\t\tn = slot.Load()\n\t\tif (n == nil || n.isEntry) && !i.dead.Load() {\n\n\t\t\tbreak\n\t\t}\n\n\t\ti.mu.Unlock()\n\t}\n\n\tdefer i.mu.Unlock()\n\n\tvar zero V\n\tvar oldEntry *entry[K, V]\n\tif n != nil {\n\n\t\toldEntry = n.entry()\n\t\tnewEntry, old, swapped := oldEntry.swap(key, new)\n\t\tif swapped {\n\t\t\tslot.Store(&newEntry.node)\n\t\t\treturn old, true\n\t\t}\n\t}\n\n\tnewEntry := newEntryNode(key, new)\n\tif oldEntry == nil {\n\n\t\tslot.Store(&newEntry.node)\n\t} else {\n\n\t\tslot.Store(ht.expand(oldEntry, newEntry, hash, hashShift, i))\n\t}\n\treturn zero, false\n}\n\nfunc (ht *HashTrieMap[K, V]) CompareAndSwap(key K, old, new V) (swapped bool) {\n\tht.init()\n\tif ht.valEqual == nil {\n\t\tpanic(\"called CompareAndSwap when value is not of comparable type\")\n\t}\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\n\ti, _, slot, n := ht.find(key, hash, ht.valEqual, old)\n\tif i != nil {\n\t\tdefer i.mu.Unlock()\n\t}\n\tif n == nil {\n\t\treturn false\n\t}\n\n\te, swapped := n.entry().compareAndSwap(key, old, new, ht.valEqual)\n\tif !swapped {\n\n\t\treturn false\n\t}\n\n\tslot.Store(&e.node)\n\treturn true\n}\n\nfunc (ht *HashTrieMap[K, V]) LoadAndDelete(key K) (value V, loaded bool) {\n\tht.init()\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\n\ti, hashShift, slot, n := ht.find(key, hash, nil, *new(V))\n\tif n == nil {\n\t\tif i != nil {\n\t\t\ti.mu.Unlock()\n\t\t}\n\t\treturn *new(V), false\n\t}\n\n\tv, e, loaded := n.entry().loadAndDelete(key)\n\tif !loaded {\n\n\t\ti.mu.Unlock()\n\t\treturn *new(V), false\n\t}\n\tif e != nil {\n\n\t\tslot.Store(&e.node)\n\t\ti.mu.Unlock()\n\t\treturn v, true\n\t}\n\n\tslot.Store(nil)\n\n\tfor i.parent != nil && i.empty() {\n\t\tif hashShift == 8*PtrSize {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n\t\t}\n\t\thashShift += nChildrenLog2\n\n\t\tparent := i.parent\n\t\tparent.mu.Lock()\n\t\ti.dead.Store(true)\n\t\tparent.children[(hash>>hashShift)&nChildrenMask].Store(nil)\n\t\ti.mu.Unlock()\n\t\ti = parent\n\t}\n\ti.mu.Unlock()\n\treturn v, true\n}\n\nfunc (ht *HashTrieMap[K, V]) Delete(key K) {\n\t_, _ = ht.LoadAndDelete(key)\n}\n\nfunc (ht *HashTrieMap[K, V]) CompareAndDelete(key K, old V) (deleted bool) {\n\tht.init()\n\tif ht.valEqual == nil {\n\t\tpanic(\"called CompareAndDelete when value is not of comparable type\")\n\t}\n\thash := ht.keyHash(abi.NoEscape(unsafe.Pointer(&key)), ht.seed)\n\n\ti, hashShift, slot, n := ht.find(key, hash, nil, *new(V))\n\tif n == nil {\n\t\tif i != nil {\n\t\t\ti.mu.Unlock()\n\t\t}\n\t\treturn false\n\t}\n\n\te, deleted := n.entry().compareAndDelete(key, old, ht.valEqual)\n\tif !deleted {\n\n\t\ti.mu.Unlock()\n\t\treturn false\n\t}\n\tif e != nil {\n\n\t\tslot.Store(&e.node)\n\t\ti.mu.Unlock()\n\t\treturn true\n\t}\n\n\tslot.Store(nil)\n\n\tfor i.parent != nil && i.empty() {\n\t\tif hashShift == 8*PtrSize {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n\t\t}\n\t\thashShift += nChildrenLog2\n\n\t\tparent := i.parent\n\t\tparent.mu.Lock()\n\t\ti.dead.Store(true)\n\t\tparent.children[(hash>>hashShift)&nChildrenMask].Store(nil)\n\t\ti.mu.Unlock()\n\t\ti = parent\n\t}\n\ti.mu.Unlock()\n\treturn true\n}\n\nfunc (ht *HashTrieMap[K, V]) find(key K, hash uintptr, valEqual equalFunc, value V) (i *indirect[K, V], hashShift uint, slot *atomic.Pointer[node[K, V]], n *node[K, V]) {\n\tfor {\n\n\t\ti = ht.root.Load()\n\t\thashShift = 8 * PtrSize\n\t\tfound := false\n\t\tfor hashShift != 0 {\n\t\t\thashShift -= nChildrenLog2\n\n\t\t\tslot = &i.children[(hash>>hashShift)&nChildrenMask]\n\t\t\tn = slot.Load()\n\t\t\tif n == nil {\n\n\t\t\t\ti = nil\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n.isEntry {\n\n\t\t\t\tif _, ok := n.entry().lookupWithValue(key, value, valEqual); !ok {\n\n\t\t\t\t\ti = nil\n\t\t\t\t\tn = nil\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti = n.indirect()\n\t\t}\n\t\tif !found {\n\t\t\tpanic(\"internal/sync.HashTrieMap: ran out of hash bits while iterating\")\n\t\t}\n\n\t\ti.mu.Lock()\n\t\tn = slot.Load()\n\t\tif !i.dead.Load() && (n == nil || n.isEntry) {\n\n\t\t\treturn\n\t\t}\n\n\t\ti.mu.Unlock()\n\t}\n}\n\nfunc (ht *HashTrieMap[K, V]) All() func(yield func(K, V) bool) {\n\tht.init()\n\treturn func(yield func(key K, value V) bool) {\n\t\tht.iter(ht.root.Load(), yield)\n\t}\n}\n\nfunc (ht *HashTrieMap[K, V]) Range(yield func(K, V) bool) {\n\tht.init()\n\tht.iter(ht.root.Load(), yield)\n}\n\nfunc (ht *HashTrieMap[K, V]) iter(i *indirect[K, V], yield func(key K, value V) bool) bool {\n\tfor j := range i.children {\n\t\tn := i.children[j].Load()\n\t\tif n == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif !n.isEntry {\n\t\t\tif !ht.iter(n.indirect(), yield) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\te := n.entry()\n\t\tfor e != nil {\n\t\t\tif !yield(e.key, e.value) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\te = e.overflow.Load()\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (ht *HashTrieMap[K, V]) Clear() {\n\tht.init()\n\n\tht.root.Store(newIndirectNode[K, V](nil))\n}\n\nconst (\n\tnChildrenLog2\t= 4\n\tnChildren\t= 1 << nChildrenLog2\n\tnChildrenMask\t= nChildren - 1\n)\n\ntype indirect[K comparable, V any] struct {\n\tnode[K, V]\n\tdead\t\tatomic.Bool\n\tmu\t\tsync.Mutex\n\tparent\t\t*indirect[K, V]\n\tchildren\t[nChildren]atomic.Pointer[node[K, V]]\n}\n\nfunc newIndirectNode[K comparable, V any](parent *indirect[K, V]) *indirect[K, V] {\n\treturn &indirect[K, V]{node: node[K, V]{isEntry: false}, parent: parent}\n}\n\nfunc (i *indirect[K, V]) empty() bool {\n\tnc := 0\n\tfor j := range i.children {\n\t\tif i.children[j].Load() != nil {\n\t\t\tnc++\n\t\t}\n\t}\n\treturn nc == 0\n}\n\ntype entry[K comparable, V any] struct {\n\tnode[K, V]\n\toverflow\tatomic.Pointer[entry[K, V]]\n\tkey\t\tK\n\tvalue\t\tV\n}\n\nfunc newEntryNode[K comparable, V any](key K, value V) *entry[K, V] {\n\treturn &entry[K, V]{\n\t\tnode:\tnode[K, V]{isEntry: true},\n\t\tkey:\tkey,\n\t\tvalue:\tvalue,\n\t}\n}\n\nfunc (e *entry[K, V]) lookup(key K) (V, bool) {\n\tfor e != nil {\n\t\tif e.key == key {\n\t\t\treturn e.value, true\n\t\t}\n\t\te = e.overflow.Load()\n\t}\n\treturn *new(V), false\n}\n\nfunc (e *entry[K, V]) lookupWithValue(key K, value V, valEqual equalFunc) (V, bool) {\n\tfor e != nil {\n\t\tif e.key == key && (valEqual == nil || valEqual(unsafe.Pointer(&e.value), abi.NoEscape(unsafe.Pointer(&value)))) {\n\t\t\treturn e.value, true\n\t\t}\n\t\te = e.overflow.Load()\n\t}\n\treturn *new(V), false\n}\n\nfunc (head *entry[K, V]) swap(key K, new V) (*entry[K, V], V, bool) {\n\tif head.key == key {\n\n\t\te := newEntryNode(key, new)\n\t\tif chain := head.overflow.Load(); chain != nil {\n\t\t\te.overflow.Store(chain)\n\t\t}\n\t\treturn e, head.value, true\n\t}\n\ti := &head.overflow\n\te := i.Load()\n\tfor e != nil {\n\t\tif e.key == key {\n\t\t\teNew := newEntryNode(key, new)\n\t\t\teNew.overflow.Store(e.overflow.Load())\n\t\t\ti.Store(eNew)\n\t\t\treturn head, e.value, true\n\t\t}\n\t\ti = &e.overflow\n\t\te = e.overflow.Load()\n\t}\n\tvar zero V\n\treturn head, zero, false\n}\n\nfunc (head *entry[K, V]) compareAndSwap(key K, old, new V, valEqual equalFunc) (*entry[K, V], bool) {\n\tif head.key == key && valEqual(unsafe.Pointer(&head.value), abi.NoEscape(unsafe.Pointer(&old))) {\n\n\t\te := newEntryNode(key, new)\n\t\tif chain := head.overflow.Load(); chain != nil {\n\t\t\te.overflow.Store(chain)\n\t\t}\n\t\treturn e, true\n\t}\n\ti := &head.overflow\n\te := i.Load()\n\tfor e != nil {\n\t\tif e.key == key && valEqual(unsafe.Pointer(&e.value), abi.NoEscape(unsafe.Pointer(&old))) {\n\t\t\teNew := newEntryNode(key, new)\n\t\t\teNew.overflow.Store(e.overflow.Load())\n\t\t\ti.Store(eNew)\n\t\t\treturn head, true\n\t\t}\n\t\ti = &e.overflow\n\t\te = e.overflow.Load()\n\t}\n\treturn head, false\n}\n\nfunc (head *entry[K, V]) loadAndDelete(key K) (V, *entry[K, V], bool) {\n\tif head.key == key {\n\n\t\treturn head.value, head.overflow.Load(), true\n\t}\n\ti := &head.overflow\n\te := i.Load()\n\tfor e != nil {\n\t\tif e.key == key {\n\t\t\ti.Store(e.overflow.Load())\n\t\t\treturn e.value, head, true\n\t\t}\n\t\ti = &e.overflow\n\t\te = e.overflow.Load()\n\t}\n\treturn *new(V), head, false\n}\n\nfunc (head *entry[K, V]) compareAndDelete(key K, value V, valEqual equalFunc) (*entry[K, V], bool) {\n\tif head.key == key && valEqual(unsafe.Pointer(&head.value), abi.NoEscape(unsafe.Pointer(&value))) {\n\n\t\treturn head.overflow.Load(), true\n\t}\n\ti := &head.overflow\n\te := i.Load()\n\tfor e != nil {\n\t\tif e.key == key && valEqual(unsafe.Pointer(&e.value), abi.NoEscape(unsafe.Pointer(&value))) {\n\t\t\ti.Store(e.overflow.Load())\n\t\t\treturn head, true\n\t\t}\n\t\ti = &e.overflow\n\t\te = e.overflow.Load()\n\t}\n\treturn head, false\n}\n\ntype node[K comparable, V any] struct {\n\tisEntry bool\n}\n\nfunc (n *node[K, V]) entry() *entry[K, V] {\n\tif !n.isEntry {\n\t\tpanic(\"called entry on non-entry node\")\n\t}\n\treturn (*entry[K, V])(unsafe.Pointer(n))\n}\n\nfunc (n *node[K, V]) indirect() *indirect[K, V] {\n\tif n.isEntry {\n\t\tpanic(\"called indirect on entry node\")\n\t}\n\treturn (*indirect[K, V])(unsafe.Pointer(n))\n}\n\nfunc runtime_rand() uint64 {\n\treturn rand.Uint64()\n}\n"
